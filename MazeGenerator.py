import random

# TODO: ensure connection between ghost house, pacman and bonus fruit
# TODO: Distribute power pellets evenly
# TODO: There are sometimes dead ends on edges of maze
# TODO: Restore A* algorithm
class MazeGenerator:
    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.maze_data = [[1 for _ in range(self.width)] for _ in range(self.height)]
        self.visited = [[False for _ in range(self.width)] for _ in range(self.height)]
        self.directions = ["up", "right", "down", "left"]

    # Generate left side of the maze_data (the right side will be generated by mirroring the left side)
    def generate(self):
        # First, a ghost house is placed in the maze_data at a random location in the vertical middle(keeping in mind that
        # the ghost house is 8x5 and that the surrounding tiles are empty, and that these empty tiles are not on the
        # edge of the maze_data)
        ghost_house_pos = self.find_available_position(self.visited, self.width // 2 - 5, -1, 10, 7)
        # ghost_house_pos = (self.width // 2 - 5 , self.height - 8)

        # now we add the empty tiles around the ghost house (the walls will be added during the maze_data population)
        for i in range(ghost_house_pos[0], ghost_house_pos[0] + 10):
            for j in range(ghost_house_pos[1], ghost_house_pos[1] + 7):
                self.maze_data[j][i] = 0
                self.visited[j][i] = True

        self.maze_data[ghost_house_pos[1] + 1][ghost_house_pos[0] + 1] = 4

        # Now we select a random tile that has not been visited yet and place pacman there. (it must not be on the
        # edge of the maze_data)
        pacman_pos = self.find_available_position(self.visited, self.width // 2 - 1, -1, 2, 1)
        self.maze_data[pacman_pos[1]][pacman_pos[0]] = 5
        self.maze_data[pacman_pos[1]][pacman_pos[0] + 1] = 0
        self.visited[pacman_pos[1]][pacman_pos[0]] = True
        self.visited[pacman_pos[1]][pacman_pos[0] + 1] = True
        self.visited[pacman_pos[1] + 1][pacman_pos[0]] = True
        self.visited[pacman_pos[1] + 1][pacman_pos[0] + 1] = True
        self.visited[pacman_pos[1] - 1][pacman_pos[0]] = True
        self.visited[pacman_pos[1] - 1][pacman_pos[0] + 1] = True

        # Now we select a random tile that has not been visited yet and place a bonus fruit. (it must not be on the
        # edge of the maze_data)
        bonus_pos = self.find_available_position(self.visited, self.width // 2 - 1, -1, 2, 1)
        self.maze_data[bonus_pos[1]][bonus_pos[0]] = 6
        self.maze_data[bonus_pos[1]][bonus_pos[0] + 1] = 0
        self.visited[bonus_pos[1]][bonus_pos[0]] = True
        self.visited[bonus_pos[1]][bonus_pos[0] + 1] = True
        self.visited[bonus_pos[1] + 1][bonus_pos[0]] = True
        self.visited[bonus_pos[1] + 1][bonus_pos[0] + 1] = True
        self.visited[bonus_pos[1] - 1][bonus_pos[0]] = True
        self.visited[bonus_pos[1] - 1][bonus_pos[0] + 1] = True

        # Generate "branches" starting from the ghost house, bonus fruit and pacman positions
        self.generate_branch(pacman_pos[0] - 1, pacman_pos[1], "left", 40, False, True)
        self.generate_branch(bonus_pos[0] - 1, bonus_pos[1], "left", 40, False, True)

        possible_ghost_house_branches = [(-1, 0, "left"), (-1, 1, "left"), (-1, 2, "left"), (-1, 3, "left"),
                                         (-1, 4, "left"), (-1, 5, "left"), (-1, 6, "left"),
                                         (0, -1, "up"), (1, -1, "up"), (2, -1, "up"), (3, -1, "up"),
                                         (0, 7, "down"), (1, 7, "down"), (2, 7, "down"), (3, 7, "down")]
        chosen_ghost_house_branches = []
        branches_count = random.randint(2, 5)
        for i in range(branches_count):
            index = random.randint(0, len(possible_ghost_house_branches) - 1)
            while ghost_house_pos[0] + possible_ghost_house_branches[index][0] < 1 or \
                    ghost_house_pos[0] + possible_ghost_house_branches[index][0] >= self.width - 1 or \
                    ghost_house_pos[1] + possible_ghost_house_branches[index][1] < 1 or \
                    ghost_house_pos[1] + possible_ghost_house_branches[index][1] >= self.height - 1:
                index = random.randint(0, len(possible_ghost_house_branches) - 1)

            chosen_ghost_house_branches.append(possible_ghost_house_branches[index])

            if index == 0 or index == len(possible_ghost_house_branches) - 2:
                for j in range(2):
                    possible_ghost_house_branches.pop(index)
            elif index == len(possible_ghost_house_branches) - 1:
                possible_ghost_house_branches.pop(index)
            else:
                for j in range(3):
                    possible_ghost_house_branches.pop(index - 1)

        for i in range(branches_count):
            self.generate_branch(ghost_house_pos[0] + chosen_ghost_house_branches[i][0],
                                 ghost_house_pos[1] + chosen_ghost_house_branches[i][1],
                                 chosen_ghost_house_branches[i][2], 40, False)



        # for i in range(len(possible_ghost_house_branches)):
        #     self.generate_branch(ghost_house_pos[0] + possible_ghost_house_branches[i][0],
        #                          ghost_house_pos[1] + possible_ghost_house_branches[i][1],
        #                          possible_ghost_house_branches[i][2], 40, False)

    def get_maze_data(self):
        # Mirror the left side of the maze_data to the right side
        for i in range(self.height):
            for j in range(self.width // 2):
                if self.maze_data[i][j] == 0 or self.maze_data[i][j] == 1 or self.maze_data[i][j] == 2 or \
                        self.maze_data[i][j] == 3:
                    self.maze_data[i][self.width - j - 1] = self.maze_data[i][j]

        return self.maze_data

    def find_available_position(self, visited, x_lock, y_lock, width, height, object_spacing=1):

        x = random.randint(1, self.width - width)
        y = random.randint(1, self.height - height)

        if x_lock != -1:
            x = x_lock
            available_y = []
            for i in range(object_spacing, self.height - height):
                size_fit = True
                for j in range(-object_spacing, width + object_spacing):
                    for k in range(-object_spacing, height + object_spacing):
                        if visited[i + k][x + j]:
                            size_fit = False
                if not visited[i][x] and size_fit:
                    available_y.append(i)
            if len(available_y) > 0:
                y = available_y[random.randint(0, len(available_y) - 1)]
                return x, y
            else:
                print("No available position in x axis", x)
                return -1, -1
        if y_lock != -1:
            y = y_lock
            available_x = []
            for i in range(object_spacing, self.width - width):
                size_fit = True
                for j in range(-object_spacing, width + object_spacing):
                    for k in range(-object_spacing, height + object_spacing):
                        if visited[y + k][i + j]:
                            size_fit = False
                if not visited[y][i] and size_fit:
                    available_x.append(i)
            if len(available_x) > 0:
                x = available_x[random.randint(0, len(available_x) - 1)]
                return x, y
            else:
                print("No available position in y axis", y)
                return -1, -1

        available_x = []
        available_y = []
        for i in range(self.width // 2 - width):
            for j in range(self.height // 2 - height):
                size_fit = True
                for k in range(-object_spacing, width + object_spacing):
                    for l in range(-object_spacing, height + object_spacing):
                        if visited[j + l][i + k]:
                            size_fit = False
                if not visited[j][i] and size_fit:
                    available_x.append(i)
                    available_y.append(j)
        if len(available_x) > 0:
            x = available_x[random.randint(0, len(available_x) - 1)]
            y = available_y[random.randint(0, len(available_y) - 1)]

        return x, y

    def generate_branch(self, x, y, direction=None, branch_length=50, backtracking=True, force_first_tile=False):
        current_x = x
        current_y = y
        if direction is None:
            my_direction = random.choice(self.directions)
        else:
            my_direction = direction

        if (not self.visited[current_y][current_x] and self.is_valid_direction(current_x, current_y, "stay")) or force_first_tile:
            self.visited[current_y][current_x] = True
            self.maze_data[current_y][current_x] = 3
            same_direction_count = 0
            while True:
                if branch_length <= 0:
                    new_x = current_x
                    new_y = current_y
                    debug_counter = 0
                    while self.no_empty_neighbors(new_x, new_y, my_direction):
                        debug_counter += 1

                        new_x, new_y = self.add_direction(new_x, new_y, my_direction)

                        if new_x < 0:
                            new_x = self.width - 1
                        if new_x >= self.width:
                            new_x = 0
                        if new_y < 0:
                            new_y = self.height - 1
                        if new_y >= self.height:
                            new_y = 0

                        self.maze_data[new_y][new_x] = 2
                        self.visited[new_y][new_x] = True
                    print("Break by length")
                    break

                if self.is_valid_direction(current_x, current_y, my_direction):
                    current_x, current_y = self.add_direction(current_x, current_y, my_direction)
                    same_direction_count += 1
                else:
                    old_direction = my_direction
                    my_direction = self.change_direction(current_x, current_y, my_direction, backtracking)
                    same_direction_count = 0
                    if old_direction == my_direction:
                        new_x = current_x
                        new_y = current_y
                        debug_counter = 0
                        while self.no_empty_neighbors(new_x, new_y, my_direction):
                            debug_counter += 1

                            new_x, new_y = self.add_direction(new_x, new_y, my_direction)

                            if new_x < 0:
                                new_x = self.width - 1
                            if new_x >= self.width:
                                new_x = 0
                            if new_y < 0:
                                new_y = self.height - 1
                            if new_y >= self.height:
                                new_y = 0

                            self.maze_data[new_y][new_x] = 2
                            self.visited[new_y][new_x] = True
                        print("Break by direction", self.no_empty_neighbors(current_x, current_y, my_direction))
                        break

                self.maze_data[current_y][current_x] = 2
                self.visited[current_y][current_x] = True
                branch_length -= 1

                if random.randint(0, 100) < 20 * same_direction_count and same_direction_count > 3 and not (
                        current_x == 0 or current_x == self.width - 1 or current_y == 0 or current_y == self.height - 1):
                    if random.randint(0, 2) == 0:
                        new_branch_direction = self.change_direction(current_x, current_y, my_direction, backtracking)
                        new_branch_x, new_branch_y = self.add_direction(current_x, current_y, new_branch_direction)
                        same_direction_count = 0
                        self.generate_branch(new_branch_x, new_branch_y, new_branch_direction, branch_length,
                                             True)
                    else:
                        same_direction_count = 0
                        my_direction = self.change_direction(current_x, current_y, my_direction, backtracking)

            new_x = current_x
            new_y = current_y
            debug_counter = 0
            while self.no_empty_neighbors(new_x, new_y, my_direction):
                debug_counter += 1

                new_x, new_y = self.add_direction(new_x, new_y, my_direction)

                if new_x < 0:
                    new_x = self.width - 1
                if new_x >= self.width:
                    new_x = 0
                if new_y < 0:
                    new_y = self.height - 1
                if new_y >= self.height:
                    new_y = 0

                self.maze_data[new_y][new_x] = 2
                self.visited[new_y][new_x] = True

    def change_direction(self, current_x, current_y, direction, backtracking=True):
        old_direction = direction
        if direction == "up" or direction == "down":
            my_direction = random.choice(["left", "right"])
        else:
            my_direction = random.choice(["up", "down"])
        continue_prev_direction = True
        if not self.is_valid_direction(current_x, current_y, my_direction):
            if my_direction == "up":
                my_direction = "down"
            elif my_direction == "down":
                my_direction = "up"
            elif my_direction == "left":
                my_direction = "right"
            elif my_direction == "right":
                my_direction = "left"
        else:
            continue_prev_direction = False
        if not self.is_valid_direction(current_x, current_y, my_direction):
            if my_direction == "up":
                my_direction = "down"
            elif my_direction == "down":
                my_direction = "up"
            elif my_direction == "left":
                my_direction = "right"
            elif my_direction == "right":
                my_direction = "left"
        else:
            continue_prev_direction = False

        if not backtracking \
                and ((my_direction == "up" and old_direction == "down")
                     or (my_direction == "down" and old_direction == "up")
                     or (my_direction == "left" and old_direction == "right")
                     or (my_direction == "right" and old_direction == "left")):
            print("Backtracking not allowed, reverting to old direction")
            return old_direction

        new_x, new_y = self.add_direction(current_x, current_y, my_direction)
        if new_x < 1 or new_x >= self.width // 2 - 1 or new_y < 1 or new_y >= self.height - 1:
            return old_direction

        if continue_prev_direction:
            return old_direction
        else:
            return my_direction

    def add_direction(self, current_x, current_y, my_direction):
        if my_direction == "up":
            current_y -= 1
        elif my_direction == "down":
            current_y += 1
        elif my_direction == "left":
            current_x -= 1
        elif my_direction == "right":
            current_x += 1
        return current_x, current_y

    def is_valid_direction(self, current_x, current_y, my_direction):
        if my_direction != "stay":
            new_x, new_y = self.add_direction(current_x, current_y, my_direction)
        else:
            new_x = current_x
            new_y = current_y
        if new_x < 1 or new_x >= self.width - 1 or new_y < 1 or new_y >= self.height - 1:
            return False
        if self.visited[new_y][new_x]:
            return False

        # check that the new position wont result in a 2x2 area of walkable tiles
        # [topleft, top, topright, left, middle, right, bottomleft, bottom, bottomright]
        walkable_tiles = [False] * 9
        for i in range(-1, 2):
            for j in range(-1, 2):
                if 0 <= new_y + j < self.height and 0 <= new_x + i < self.width and self.visited[new_y + j][new_x + i]:
                    walkable_tiles[(j + 1) * 3 + i + 1] = True

        walkable_tiles[4] = True
        if walkable_tiles[0] and walkable_tiles[1] and walkable_tiles[3] and walkable_tiles[4] \
                or walkable_tiles[1] and walkable_tiles[2] and walkable_tiles[4] and walkable_tiles[5] \
                or walkable_tiles[3] and walkable_tiles[4] and walkable_tiles[6] and walkable_tiles[7] \
                or walkable_tiles[4] and walkable_tiles[5] and walkable_tiles[7] and walkable_tiles[8]:
            return False

        return True

    def no_empty_neighbors(self, current_x, current_y, my_direction):

        neighbors_to_check = []
        if my_direction == "up":
            if current_x - 1 < 0:
                neighbors_to_check = [(self.width -1, current_y), (current_x, current_y - 1), (current_x + 1, current_y)]
            elif current_x + 1 >= self.width:
                neighbors_to_check = [(current_x - 1, current_y), (current_x, current_y - 1), (0, current_y)]
            elif current_y - 1 < 0:
                neighbors_to_check = [(current_x - 1, current_y), (current_x, self.height - 1), (current_x + 1, current_y)]
            else:
                neighbors_to_check = [(current_x - 1, current_y), (current_x, current_y - 1), (current_x + 1, current_y)]
        elif my_direction == "down":
            if current_x - 1 < 0:
                neighbors_to_check = [(self.width -1, current_y), (current_x, current_y + 1), (current_x + 1, current_y)]
            elif current_x + 1 >= self.width:
                neighbors_to_check = [(current_x - 1, current_y), (current_x, current_y + 1), (0, current_y)]
            elif current_y + 1 >= self.height:
                neighbors_to_check = [(current_x - 1, current_y), (current_x, 0), (current_x + 1, current_y)]
            else:
                neighbors_to_check = [(current_x - 1, current_y), (current_x, current_y + 1), (current_x + 1, current_y)]
        elif my_direction == "left":
            if current_y - 1 < 0:
                neighbors_to_check = [(current_x, self.height - 1), (current_x - 1, current_y), (current_x, current_y + 1)]
            elif current_y + 1 >= self.height:
                neighbors_to_check = [(current_x, current_y - 1), (current_x - 1, current_y), (current_x, 0)]
            elif current_x - 1 < 0:
                neighbors_to_check = [(self.width - 1, current_y), (current_x, current_y - 1), (current_x, current_y + 1)]
            else:
                neighbors_to_check = [(current_x, current_y - 1), (current_x - 1, current_y), (current_x, current_y + 1)]
        elif my_direction == "right":
            if current_y - 1 < 0:
                neighbors_to_check = [(current_x, self.height - 1), (current_x + 1, current_y), (current_x, current_y + 1)]
            elif current_y + 1 >= self.height:
                neighbors_to_check = [(current_x, current_y - 1), (current_x + 1, current_y), (current_x, 0)]
            elif current_x + 1 >= self.width:
                neighbors_to_check = [(0, current_y), (current_x, current_y - 1), (current_x, current_y + 1)]
            else:
                neighbors_to_check = [(current_x, current_y - 1), (current_x + 1, current_y), (current_x, current_y + 1)]

        for x, y in neighbors_to_check:
            if self.visited[y][x]:
                return False

        return True
