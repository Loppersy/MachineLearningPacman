import random

import numpy as np
import pygame

import utilities
from AStar import AStar, Node

BRANCH_LENGTH = 30
BRANCH_MIN_LENGTH = 3
BRANCH_CHANCE_PER_LENGTH = 20
BRANCH_CHANCE_PENALTY_PER_BRANCH = 10
BRANCH_DIRCHANGE_CHANCE = 10
BRANCH_CAN_WRAP_AROUND = False
POWER_PELLETS_PER_SIDE = 2


class MazeGenerator:
    def __init__(self, width, height):

        self.width = width
        self.height = height
        self.maze_data = [[1 for _ in range(self.width)] for _ in range(self.height)]
        self.blocked_positions = [[False for _ in range(self.width)] for _ in range(self.height)]

    # Generate left side of the maze_data (the right side will be generated by mirroring the left side)
    def generate(self):

        starting_branches_positions, pacman_pos = self.get_starting_positions()

        for branch_position in starting_branches_positions:
            self.generate_branch(branch_position[0], branch_position[1], branch_position[2], BRANCH_LENGTH)

        # Mirror the left side of the maze_data to the right side
        self.mirror_maze()

        self.remove_dead_ends()

        if not self.ensure_all_maze_connected(pacman_pos):
            return False

        self.add_power_pellets(POWER_PELLETS_PER_SIDE)
        self.add_side_tunnel()
        self.mirror_maze()
        return True

    def ensure_all_maze_connected(self, pacman_pos):
        # ensure that all tiles are accessible. if not, create a tunnel between the ghost house and pacman and the bonus
        # fruit
        path_finder = AStar()
        walkable_tiles = []
        for i in range(len(self.maze_data)):
            for j in range(len(self.maze_data[i])):
                if self.maze_data[i][j] != 1:
                    walkable_tiles.append((j, i))
        # order the walkable tiles by distance to pacman using numpy
        walkable_tiles = np.array(walkable_tiles)
        pacman_pos_array = np.array(pacman_pos)
        walkable_tiles = walkable_tiles[np.argsort(np.linalg.norm(walkable_tiles - pacman_pos_array, axis=1))]
        # convert the numpy array back to a list of tuples
        walkable_tiles = [tuple(x) for x in walkable_tiles]
        for walkable_tile in walkable_tiles:
            if not path_finder.is_reachable(Node(pacman_pos), Node(walkable_tile), self.maze_data):
                walkable_tile_closest_pos = \
                    path_finder.get_path(Node(walkable_tile), Node(pacman_pos), self.maze_data, False)[
                        -1]
                pacman_closest_pos = \
                    path_finder.get_path(Node(pacman_pos), Node(walkable_tile_closest_pos), self.maze_data, False)[-1]

                # utilities.add_highlighted_tile(pacman_closest_pos, (255, 0, 0))
                # utilities.add_highlighted_tile(walkable_tile_closest_pos, (0, 255, 0))

                # if closest_node_middle_pos == closest_node_lowest_pos:
                #     closest_node_middle_pos = middle_pos
                connecting_tunel = path_finder.get_tunel(Node((pacman_closest_pos[0]-1, pacman_closest_pos[1])),
                                                         Node(walkable_tile_closest_pos),
                                                         self.maze_data)
                if connecting_tunel is not None:
                    self.create_tunel(connecting_tunel)
                else:
                    print("no connecting tunel found")
                    return False
        return True

    def mirror_maze(self):
        for i in range(self.height):
            for j in range(self.width // 2):
                if self.maze_data[i][j] == 0 or self.maze_data[i][j] == 1 or self.maze_data[i][j] == 2 or \
                        self.maze_data[i][j] == 3:
                    self.maze_data[i][self.width - j - 1] = self.maze_data[i][j]
                else:
                    self.maze_data[i][self.width - j - 1] = 0

    def get_maze_data(self):
        # for i in range(self.height):
        #     for j in range(self.width):
        #         if self.blocked_positions[i][j]:
        #             utilities.add_highlighted_tile((j, i), (255, 255, 255))
        return self.maze_data

    def find_available_position(self, visited, x_lock, y_lock, width, height, object_spacing=1):

        x = random.randint(1, self.width - width)
        y = random.randint(1, self.height - height)

        if x_lock != -1:
            x = x_lock
            available_y = []
            for i in range(object_spacing, self.height - height):
                size_fit = True
                for j in range(-object_spacing, width + object_spacing):
                    for k in range(-object_spacing, height + object_spacing):
                        if (not self.height > i + k >= 0 or not self.width > x + j >= 0) \
                                or visited[i + k][x + j]:
                            size_fit = False
                if not visited[i][x] and size_fit:
                    available_y.append(i)
            if len(available_y) > 0:
                y = available_y[random.randint(0, len(available_y) - 1)]
                return x, y
            else:
                print("No available position in x axis", x)
                return -1, -1
        if y_lock != -1:
            y = y_lock
            available_x = []
            for i in range(object_spacing, self.width - width):
                size_fit = True
                for j in range(-object_spacing, width + object_spacing):
                    for k in range(-object_spacing, height + object_spacing):
                        if visited[y + k][i + j]:
                            size_fit = False
                if not visited[y][i] and size_fit:
                    available_x.append(i)
            if len(available_x) > 0:
                x = available_x[random.randint(0, len(available_x) - 1)]
                return x, y
            else:
                print("No available position in y axis", y)
                return -1, -1

        available_x = []
        available_y = []
        for i in range(self.width // 2 - width):
            for j in range(self.height // 2 - height):
                size_fit = True
                for k in range(-object_spacing, width + object_spacing):
                    for l in range(-object_spacing, height + object_spacing):
                        if visited[j + l][i + k]:
                            size_fit = False
                if not visited[j][i] and size_fit:
                    available_x.append(i)
                    available_y.append(j)
        if len(available_x) > 0:
            x = available_x[random.randint(0, len(available_x) - 1)]
            y = available_y[random.randint(0, len(available_y) - 1)]

        return x, y

    # def generate_branch(self, x, y, direction=None, branch_length=50, backtracking=False, force_first_tile=False,
    #                     branch_number=1):
    #     current_x = x
    #     current_y = y
    #     if direction is None:
    #         my_direction = random.choice(self.directions)
    #     else:
    #         my_direction = direction
    #
    #     if (not self.blocked_positions[current_y][current_x] and self.does_not_create_2x2(current_x, current_y,
    #                                                                             "stay", True)) or force_first_tile:
    #         self.blocked_positions[current_y][current_x] = True
    #         self.maze_data[current_y][current_x] = 2
    #         same_direction_count = 0
    #         while True:
    #
    #             if self.does_not_create_2x2(current_x, current_y, my_direction, BRANCH_CAN_WRAP_AROUND):
    #                 current_x, current_y = self.add_direction(current_x, current_y, my_direction, True)
    #                 same_direction_count += 1
    #             else:
    #                 old_direction = my_direction
    #                 my_direction = self.change_direction(current_x, current_y, my_direction, backtracking)
    #                 same_direction_count = 0
    #                 if old_direction == my_direction:
    #                     self.continue_tunel_until_connection(current_x, current_y, my_direction)
    #                     break
    #                 current_x, current_y = self.add_direction(current_x, current_y, my_direction, True)
    #
    #             self.maze_data[current_y][current_x] = 2
    #             self.blocked_positions[current_y][current_x] = True
    #             branch_length -= 1
    #
    #             if branch_length <= 0:
    #                 self.continue_tunel_until_connection(current_x, current_y, my_direction)
    #                 break
    #
    #             if random.randint(0, 100) < BRANCH_CHANCE_PER_LENGTH * same_direction_count \
    #                     and same_direction_count > BRANCH_MIN_LENGTH \
    #                     and not (
    #                     current_x == 0 or current_x == self.width - 1 or current_y == 0 or current_y == self.height - 1):
    #                 if random.randint(0, 100) < BRANCH_DIRCHANGE_CHANCE - BRANCH_CHANCE_PENALTY_PER_BRANCH * (
    #                         branch_number - 1):
    #                     new_branch_direction = self.change_direction(current_x, current_y, my_direction, backtracking)
    #                     new_branch_x, new_branch_y = self.add_direction(current_x, current_y, new_branch_direction)
    #                     same_direction_count = 0
    #                     self.generate_branch(new_branch_x, new_branch_y, new_branch_direction, branch_length,
    #                                          True, False, branch_number + 1)
    #                 else:
    #                     same_direction_count = 0
    #                     my_direction = self.change_direction(current_x, current_y, my_direction, backtracking)

    def continue_tunel_until_connection(self, x, y, direction):
        current_x = x
        current_y = y
        self.maze_data[current_y][current_x] = 2
        my_direction = direction

        # utilities.add_highlighted_tile(self.add_direction(current_x, current_y, my_direction, True), (255, 0, 0))
        tunel_length = 0
        while self.no_empty_neighbors(current_x, current_y, my_direction):
            maze_height = len(self.maze_data)
            can_wrap_around = False
            if maze_height // 3 <= current_y <= maze_height // 3 * 2:
                can_wrap_around = True

            tunel_length += 1
            if tunel_length > 6 and random.randint(0, 2) == 0:
                new_branch_direction = self.change_direction(current_x, current_y, my_direction, can_wrap_around)
                new_branch_x, new_branch_y = self.add_direction(current_x, current_y, new_branch_direction)

                if self.does_not_create_2x2(new_branch_x, new_branch_y, new_branch_direction, can_wrap_around):
                    self.generate_branch(new_branch_x, new_branch_y, new_branch_direction, BRANCH_LENGTH)

            if (not self.does_not_create_2x2(current_x, current_y, my_direction, can_wrap_around) or \
                    self.blocked_positions[self.add_direction(current_x, current_y, my_direction, True)[1]][
                        self.add_direction(current_x, current_y, my_direction, True)[0]]):
                my_direction = self.change_direction(current_x, current_y, my_direction, False, True)
                print("change direction", my_direction)

            current_x, current_y = self.add_direction(current_x, current_y, my_direction, True)
            self.blocked_positions[current_y][current_x] = True
            self.maze_data[current_y][current_x] = 2

    def change_direction(self, current_x, current_y, direction, backtracking=True, wrap_around=False):
        wrap_around = self.height // 3 <= current_y <= self.height // 3 * 2

        old_direction = direction
        if direction == "up" or direction == "down":
            my_direction = random.choice(["left", "right"])
        else:
            my_direction = random.choice(["up", "down"])
        continue_prev_direction = True
        if not self.does_not_create_2x2(current_x, current_y, my_direction):
            if my_direction == "up":
                my_direction = "down"
            elif my_direction == "down":
                my_direction = "up"
            elif my_direction == "left":
                my_direction = "right"
            elif my_direction == "right":
                my_direction = "left"
        else:
            continue_prev_direction = False
        if not self.does_not_create_2x2(current_x, current_y, my_direction):
            if my_direction == "up":
                my_direction = "down"
            elif my_direction == "down":
                my_direction = "up"
            elif my_direction == "left":
                my_direction = "right"
            elif my_direction == "right":
                my_direction = "left"
        else:
            continue_prev_direction = False

        if not backtracking \
                and ((my_direction == "up" and old_direction == "down")
                     or (my_direction == "down" and old_direction == "up")
                     or (my_direction == "left" and old_direction == "right")
                     or (my_direction == "right" and old_direction == "left")):
            print("Backtracking not allowed, reverting to old direction")
            return old_direction

        new_x, new_y = self.add_direction(current_x, current_y, my_direction)
        if (new_x < 1 or new_x > self.width // 2 - 1 or new_y < 1 or new_y > self.height - 1) and not wrap_around:
            return old_direction

        if continue_prev_direction:
            return old_direction
        else:
            return my_direction

    def add_direction(self, current_x, current_y, my_direction, wrap_around=False):
        if my_direction == "up":
            current_y -= 1
        elif my_direction == "down":
            current_y += 1
        elif my_direction == "left":
            current_x -= 1
        elif my_direction == "right":
            current_x += 1

        if wrap_around:
            if current_x < 0:
                current_x = self.width - 1
            if current_x >= self.width:
                current_x = 0
            if current_y < 0:
                current_y = self.height - 1
            if current_y >= self.height:
                current_y = 0
        else:
            if current_x < 0:
                current_x = 1
            if current_x >= self.width:
                current_x = self.width - 2
            if current_y < 0:
                current_y = 1
            if current_y >= self.height:
                current_y = self.height - 2
        return current_x, current_y

    def does_not_create_2x2(self, current_x, current_y, my_direction, wrap_around=False):
        if my_direction != "stay":
            new_x, new_y = self.add_direction(current_x, current_y, my_direction, True)
        else:
            new_x = current_x
            new_y = current_y

        wrap_around = self.height // 3 <= new_y <= self.height // 3 * 2

        if (new_x < 1 or new_x >= self.width - 1 or new_y < 1 or new_y >= self.height - 1) and not wrap_around:
            return False
        if self.blocked_positions[new_y][new_x]:
            return False

        # check that the new position wont result in a 2x2 area of walkable tiles
        # [bottomleft, bottom, bottomright, left, middle, right, topleft, top, topright ]
        color = (pygame.Color('white'))
        color.hsva = (random.randint(0, 360), 100, 100, 100)

        walkable_tiles = [False] * 9
        for i in range(-1, 2):
            for j in range(-1, 2):
                if wrap_around:
                    temp_y = new_y + j
                    if temp_y < 0:
                        temp_y += self.height
                    elif temp_y >= self.height:
                        temp_y -= self.height
                    temp_x = new_x + i
                    if temp_x < 0:
                        temp_x += self.width
                    elif temp_x >= self.width:
                        temp_x -= self.width

                    if self.maze_data[temp_y][temp_x] != 1:
                        walkable_tiles[(j + 1) * 3 + i + 1] = True

                else:
                    if 0 <= new_y + j < self.height and 0 <= new_x + i < self.width and self.maze_data[new_y + j][
                        new_x + i] != 1:
                        walkable_tiles[(j + 1) * 3 + i + 1] = True

        walkable_tiles[4] = True
        if (walkable_tiles[0] and walkable_tiles[1] and walkable_tiles[3] and walkable_tiles[4]) \
                or (walkable_tiles[1] and walkable_tiles[2] and walkable_tiles[4] and walkable_tiles[5]) \
                or (walkable_tiles[3] and walkable_tiles[4] and walkable_tiles[6] and walkable_tiles[7]) \
                or (walkable_tiles[4] and walkable_tiles[5] and walkable_tiles[7] and walkable_tiles[8]):
            return False

        return True

    def no_empty_neighbors(self, current_x, current_y, my_direction, ignore_visited_walls=True):

        neighbors_to_check = []
        if my_direction == "up":
            if current_x - 1 < 0:
                neighbors_to_check = [(self.width - 1, current_y), (current_x, current_y - 1),
                                      (current_x + 1, current_y)]
            elif current_x + 1 >= self.width:
                neighbors_to_check = [(current_x - 1, current_y), (current_x, current_y - 1), (0, current_y)]
            elif current_y - 1 < 0:
                neighbors_to_check = [(current_x - 1, current_y), (current_x, self.height - 1),
                                      (current_x + 1, current_y)]
            else:
                neighbors_to_check = [(current_x - 1, current_y), (current_x, current_y - 1),
                                      (current_x + 1, current_y)]
        elif my_direction == "down":
            if current_x - 1 < 0:
                neighbors_to_check = [(self.width - 1, current_y), (current_x, current_y + 1),
                                      (current_x + 1, current_y)]
            elif current_x + 1 >= self.width:
                neighbors_to_check = [(current_x - 1, current_y), (current_x, current_y + 1), (0, current_y)]
            elif current_y + 1 >= self.height:
                neighbors_to_check = [(current_x - 1, current_y), (current_x, 0), (current_x + 1, current_y)]
            else:
                neighbors_to_check = [(current_x - 1, current_y), (current_x, current_y + 1),
                                      (current_x + 1, current_y)]
        elif my_direction == "left":
            if current_y - 1 < 0:
                neighbors_to_check = [(current_x, self.height - 1), (current_x - 1, current_y),
                                      (current_x, current_y + 1)]
            elif current_y + 1 >= self.height:
                neighbors_to_check = [(current_x, current_y - 1), (current_x - 1, current_y), (current_x, 0)]
            elif current_x - 1 < 0:
                neighbors_to_check = [(self.width - 1, current_y), (current_x, current_y - 1),
                                      (current_x, current_y + 1)]
            else:
                neighbors_to_check = [(current_x, current_y - 1), (current_x - 1, current_y),
                                      (current_x, current_y + 1)]
        elif my_direction == "right":
            if current_y - 1 < 0:
                neighbors_to_check = [(current_x, self.height - 1), (current_x + 1, current_y),
                                      (current_x, current_y + 1)]
            elif current_y + 1 >= self.height:
                neighbors_to_check = [(current_x, current_y - 1), (current_x + 1, current_y), (current_x, 0)]
            elif current_x + 1 >= self.width:
                neighbors_to_check = [(0, current_y), (current_x, current_y - 1), (current_x, current_y + 1)]
            else:
                neighbors_to_check = [(current_x, current_y - 1), (current_x + 1, current_y),
                                      (current_x, current_y + 1)]

        for x, y in neighbors_to_check:
            if ignore_visited_walls:
                if self.maze_data[y][x] != 1:
                    return False
            else:
                if self.blocked_positions[y][x]:
                    return False

        return True

    def ensure_all_tiles_accessible(self, pacman_pos):
        positions_to_check = []
        for y in range(self.height):
            for x in range(self.width):
                if self.maze_data[y][x] != 1 and self.blocked_positions[y][x]:
                    positions_to_check.append((x, y))

        path_finder = AStar()
        while len(positions_to_check) > 1:
            old_len = len(positions_to_check)
            path = path_finder.get_path(Node((pacman_pos[0], pacman_pos[1])),
                                        Node((positions_to_check[1][0], positions_to_check[1][1])), self.maze_data)
            for x, y in path:
                for i, j in positions_to_check:
                    if i == x and j == y:
                        positions_to_check.remove((i, j))
                        break

            if len(positions_to_check) == old_len:
                return False

        return True

    def create_tunel(self, path):
        if not path:
            return
        for x, y in path:
            utilities.add_highlighted_tile((x, y), (0, 255, 0))
            if self.maze_data[y][x] == 1 and not self.blocked_positions[y][x]:
                self.maze_data[y][x] = 2

    def add_power_pellets(self, number_of_power_pellets):
        power_pellets_pos = []
        attempted_positions = []
        power_pellets_added = 0
        while power_pellets_added < number_of_power_pellets:
            x = random.randint(0, self.width // 3 - 1)
            y = random.randint(0, self.height - 1)
            attempted_positions.append((x, y))
            if len(attempted_positions) > self.get_number_of_pellets():
                print("Could not add all power pellets")
                return
            if self.maze_data[y][x] == 2:
                pick_new = False
                if len(power_pellets_pos) > 0:
                    for i, j in power_pellets_pos:
                        if abs(j - y) < self.get_diff_between_h_l_pellet() // (number_of_power_pellets + 1):
                            pick_new = True
                            break
                if pick_new:
                    continue
                power_pellets_pos.append((x, y))
                self.maze_data[y][x] = 3
                power_pellets_added += 1

    def get_number_of_pellets(self):
        number_of_pellets = 0
        for y in range(self.height):
            for x in range(self.width):
                if self.maze_data[y][x] == 2:
                    number_of_pellets += 1

        return number_of_pellets

    def get_diff_between_h_l_pellet(self):
        lowest_y = self.height
        highest_y = 0
        for y in range(self.height):
            for x in range(self.width):
                if self.maze_data[y][x] == 2:
                    if y < lowest_y:
                        lowest_y = y
                    if y > highest_y:
                        highest_y = y

        return highest_y - lowest_y

    def get_starting_positions(self):
        # First, a ghost house is placed in the maze_data at a random location in the vertical middle(keeping in mind that
        # the ghost house is 8x5 and that the surrounding tiles are empty, and that these empty tiles are not on the
        # edge of the maze_data)
        self.maze_data = [[1 for _ in range(self.width)] for _ in range(self.height)]
        self.blocked_positions = [[False for _ in range(self.width)] for _ in range(self.height)]
        # add the borders to the blocked positions
        for i in range(self.width):
            self.blocked_positions[0][i] = True
            self.blocked_positions[self.height - 1][i] = True
        for i in range(self.height):
            self.blocked_positions[i][0] = True
            self.blocked_positions[i][self.width - 1] = True
        ghost_house_pos = self.find_available_position(self.blocked_positions, self.width // 2 - 5, -1, 10, 7, 4)
        # ghost_house_pos = (self.width // 2 - 5 , 2)

        # now we add the empty tiles around the ghost house and place the ghost house
        for i in range(ghost_house_pos[0], ghost_house_pos[0] + 10):
            for j in range(ghost_house_pos[1], ghost_house_pos[1] + 7):
                self.maze_data[j][i] = 0
                self.blocked_positions[j][i] = True

        ghost_house_dimensions = (8, 5)
        for i in range(1, ghost_house_dimensions[0] + 1):
            for j in range(1, ghost_house_dimensions[1] + 1):
                if 0 <= i <= ghost_house_dimensions[0] and 0 <= j <= ghost_house_dimensions[1]:
                    self.maze_data[ghost_house_pos[1] + j][ghost_house_pos[0] + i] = 1
                    # utilities.highlighted_tiles.append(((ghost_house_pos[0] + i, ghost_house_pos[1] + j), (255, 0, 0)))

        self.maze_data[ghost_house_pos[1] + 1][ghost_house_pos[0] + 1] = 4

        # Now we select a random tile that has not been blocked_positions yet and place pacman there. (it must not be on the
        # edge of the maze_data)
        pacman_pos = self.find_available_position(self.blocked_positions, self.width // 2 - 1, -1, 2, 2, 2)
        # pacman_pos = (self.width // 2 - 1, 10)
        self.maze_data[pacman_pos[1]][pacman_pos[0]] = 5
        self.maze_data[pacman_pos[1]][pacman_pos[0] + 1] = 0
        self.blocked_positions[pacman_pos[1]][pacman_pos[0]] = True
        self.blocked_positions[pacman_pos[1]][pacman_pos[0] + 1] = True
        self.blocked_positions[pacman_pos[1] + 1][pacman_pos[0]] = True
        self.blocked_positions[pacman_pos[1] + 1][pacman_pos[0] + 1] = True
        self.blocked_positions[pacman_pos[1] - 1][pacman_pos[0]] = True
        self.blocked_positions[pacman_pos[1] - 1][pacman_pos[0] + 1] = True

        # Now we select a random tile that has not been blocked_positions yet and place a bonus fruit. (it must not be on the
        # edge of the maze_data)
        bonus_pos = self.find_available_position(self.blocked_positions, self.width // 2 - 1, -1, 2, 2, 2)
        # bonus_pos = (self.width // 2 - 8, 12)
        self.maze_data[bonus_pos[1]][bonus_pos[0]] = 6
        self.maze_data[bonus_pos[1]][bonus_pos[0] + 1] = 0
        self.blocked_positions[bonus_pos[1]][bonus_pos[0]] = True
        self.blocked_positions[bonus_pos[1]][bonus_pos[0] + 1] = True
        self.blocked_positions[bonus_pos[1] + 1][bonus_pos[0]] = True
        self.blocked_positions[bonus_pos[1] + 1][bonus_pos[0] + 1] = True
        self.blocked_positions[bonus_pos[1] - 1][bonus_pos[0]] = True
        self.blocked_positions[bonus_pos[1] - 1][bonus_pos[0] + 1] = True

        random_pos = self.find_available_position(self.blocked_positions, self.width // 2 - 1, -1, 2, 2, 2)
        if random_pos != (-1, -1):
            self.maze_data[random_pos[1]][random_pos[0]] = 2
            self.maze_data[random_pos[1]][random_pos[0] + 1] = 2
            self.blocked_positions[random_pos[1]][random_pos[0]] = True
            self.blocked_positions[random_pos[1]][random_pos[0] + 1] = True
            self.blocked_positions[random_pos[1] + 1][random_pos[0]] = True
            self.blocked_positions[random_pos[1] + 1][random_pos[0] + 1] = True
            self.blocked_positions[random_pos[1] - 1][random_pos[0]] = True
            self.blocked_positions[random_pos[1] - 1][random_pos[0] + 1] = True

        # Generate "branches" starting from the ghost house, bonus fruit and pacman positions
        # self.generate_branch(bonus_pos[0] - 6, bonus_pos[1]+1, "right", BRANCH_LENGTH, False, True)

        possible_ghost_house_branches = [(-1, 0, "left"), (-1, 1, "left"), (-1, 2, "left"), (-1, 3, "left"),
                                         (-1, 4, "left"), (-1, 5, "left"), (-1, 6, "left")]
        up_possible_ghost_house_branches = [(0, -1, "up"), (1, -1, "up"), (2, -1, "up"), (3, -1, "up")]
        down_possible_ghost_house_branches = [(0, 7, "down"), (1, 7, "down"), (2, 7, "down"), (3, 7, "down")]

        chosen_ghost_house_branches = [
            up_possible_ghost_house_branches[random.randint(0, len(up_possible_ghost_house_branches) - 1)],
            down_possible_ghost_house_branches[random.randint(0, len(down_possible_ghost_house_branches) - 1)]]

        branches_count = random.randint(1, 2)
        for i in range(branches_count):
            index = random.randint(0, len(possible_ghost_house_branches) - 1)
            while (ghost_house_pos[0] + possible_ghost_house_branches[index][0] < 1
                   or ghost_house_pos[0] + possible_ghost_house_branches[index][0] >= self.width - 1
                   or ghost_house_pos[1] + possible_ghost_house_branches[index][1] < 1 or ghost_house_pos[1] +
                   possible_ghost_house_branches[index][1] >= self.height - 1) \
                    and len(possible_ghost_house_branches) > 1:
                possible_ghost_house_branches.pop(index)
                index = random.randint(0, len(possible_ghost_house_branches) - 1)

            if len(possible_ghost_house_branches) < 1: print(" No possible branches left")
            chosen_ghost_house_branches.append(possible_ghost_house_branches[index])

            if (index == 0 or index == len(possible_ghost_house_branches) - 2) and len(
                    possible_ghost_house_branches) > 2:
                for j in range(2):
                    possible_ghost_house_branches.pop(index)
            elif index == len(possible_ghost_house_branches) - 1 and len(possible_ghost_house_branches) > 1:
                possible_ghost_house_branches.pop(index)
            elif len(possible_ghost_house_branches) > 3:
                for j in range(3):
                    possible_ghost_house_branches.pop(index - 1)

        starting_positions = [(pacman_pos[0] - 1, pacman_pos[1], "left"),
                              (bonus_pos[0] - 1, bonus_pos[1], "left")]

        if random_pos != (-1, -1):
            starting_positions.append((random_pos[0] - 1, random_pos[1], "left"))

        for branch in chosen_ghost_house_branches:
            starting_positions.append((ghost_house_pos[0] + branch[0], ghost_house_pos[1] + branch[1], None))

        return starting_positions, pacman_pos

    def generate_branch(self, x, y, direction, branch_length, directions_to_avoid=None):
        if self.creates_walkable_area(x, y) \
                or self.blocked_positions[x][y] \
                or x > self.width // 2 - 1:
            return

        branch_positions = []
        self.maze_data[y][x] = 2
        current_branch_length = branch_length - 1

        new_x, new_y = x, y
        if direction is not None:
            new_direction = direction
        else:
            new_direction = self.get_random_valid_direction(new_x, new_y, directions_to_avoid)

        length_without_branch = 0
        length_without_direction_change = 0
        while current_branch_length > 0 or (current_branch_length <= 0 and self.is_dead_end(new_x, new_y)):
            current_branch_length -= 1
            # Add the new position to the branch
            if not self.is_valid_direction(new_x, new_y, new_direction):
                if new_direction == "up" or new_direction == "down":
                    new_directions_to_avoid = ["up", "down"]
                else:
                    new_directions_to_avoid = ["left", "right"]
                new_direction = self.get_random_valid_direction(new_x, new_y, new_directions_to_avoid)
                length_without_direction_change = 0
                if new_direction is None:
                    break

            new_x, new_y = self.add_direction(new_x, new_y, new_direction, False)
            if self.is_walkable((new_x, new_y)) or new_x > self.width // 2 - 1:
                break
            self.maze_data[new_y][new_x] = 2
            branch_positions.append((new_x, new_y))

            length_without_branch += 1
            length_without_direction_change += 1
            if branch_length - current_branch_length > BRANCH_MIN_LENGTH and length_without_direction_change >= BRANCH_MIN_LENGTH:
                if random.randint(0, 100) < BRANCH_DIRCHANGE_CHANCE or length_without_branch > BRANCH_MIN_LENGTH * 3:
                    opposite_direction = self.get_opposite_direction(new_direction)
                    branch_direction = self.get_random_valid_direction(new_x, new_y,
                                                                       [new_direction, opposite_direction])
                    branch_positions.clear()
                    self.generate_branch(new_x, new_y, branch_direction, BRANCH_LENGTH)
                    length_without_branch = 0

                if random.randint(0,
                                  100) < BRANCH_DIRCHANGE_CHANCE or length_without_direction_change > BRANCH_MIN_LENGTH * 3:
                    if new_direction == "up" or new_direction == "down":
                        new_directions_to_avoid = ["up", "down"]
                    else:
                        new_directions_to_avoid = ["left", "right"]
                    new_direction = self.get_random_valid_direction(new_x, new_y, new_directions_to_avoid)
                    length_without_direction_change = 0

    def get_valid_directions(self, x, y, directions_to_avoid=None):
        valid_directions = []
        if not self.creates_walkable_area(x, y - 1) \
                and not self.blocked_positions[y - 1][x] \
                and (directions_to_avoid is None or "up" not in directions_to_avoid) \
                and x != self.width // 2 - 1:
            valid_directions.append("up")
        if not self.creates_walkable_area(x, y + 1) \
                and not self.blocked_positions[y + 1][x] \
                and (directions_to_avoid is None or "down" not in directions_to_avoid) \
                and x != self.width // 2 - 1:
            valid_directions.append("down")
        if not self.creates_walkable_area(x - 1, y) \
                and not self.blocked_positions[y][x - 1] \
                and (directions_to_avoid is None or "left" not in directions_to_avoid) \
                and x != self.width // 2 - 1:
            valid_directions.append("left")
        if not self.creates_walkable_area(x + 1, y) \
                and not self.blocked_positions[y][x + 1] \
                and (directions_to_avoid is None or "right" not in directions_to_avoid) \
                and x != self.width // 2 - 1:
            valid_directions.append("right")

        return valid_directions

    def creates_walkable_area(self, x, y):
        directions_to_check = [(-1, -1), (0, -1), (1, -1),
                               (-1, 0), (1, 0),
                               (-1, 1), (0, 1), (1, 1)]
        positions_to_check = []
        for direction in directions_to_check:
            temp_x = x + direction[0]
            temp_y = y + direction[1]
            if temp_y > self.height - 1:
                temp_y = self.height - 1
            if temp_y < 0:
                temp_y = 0
            if temp_x > self.width // 2 - 1:
                temp_x = self.width // 2 - 1
            if temp_x < 0:
                temp_x = 0

            positions_to_check.append((temp_x, temp_y))

        # Check up left corner
        if self.is_walkable(positions_to_check[0]) \
                and self.is_walkable(positions_to_check[1]) \
                and self.is_walkable(positions_to_check[3]):
            return True

        # Check up right corner
        if self.is_walkable(positions_to_check[2]) \
                and self.is_walkable(positions_to_check[1]) \
                and self.is_walkable(positions_to_check[4]):
            return True

        # Check down left corner
        if self.is_walkable(positions_to_check[5]) \
                and self.is_walkable(positions_to_check[3]) \
                and self.is_walkable(positions_to_check[6]):
            return True

        # Check down right corner
        if self.is_walkable(positions_to_check[7]) \
                and self.is_walkable(positions_to_check[4]) \
                and self.is_walkable(positions_to_check[6]):
            return True

        return False

    def is_walkable(self, position):
        return self.maze_data[position[1]][position[0]] != 1

    def is_inside_maze(self, position, margin=0):
        if position[0] < margin \
                or position[0] >= self.width - margin \
                or position[1] < margin \
                or position[1] >= self.height - margin:
            return False
        return True

    def get_random_valid_direction(self, new_x, new_y, directions_to_avoid):
        valid_directions = self.get_valid_directions(new_x, new_y, directions_to_avoid)
        if len(valid_directions) < 1:
            return None
        new_direction = random.choice(valid_directions)
        temp_x, temp_y = self.add_direction(new_x, new_y, new_direction)
        while not self.is_valid_direction(temp_x, temp_y, new_direction):
            valid_directions.remove(new_direction)
            if len(valid_directions) < 1:
                return None
            new_direction = random.choice(valid_directions)
            temp_x, temp_y = self.add_direction(new_x, new_y, new_direction)

        return new_direction

    def is_valid_direction(self, new_x, new_y, new_direction):
        new_x, new_y = self.add_direction(new_x, new_y, new_direction)
        if not self.is_inside_maze((new_x, new_y)) \
                or self.creates_walkable_area(new_x, new_y) \
                or self.blocked_positions[new_y][new_x]:
            return False
        return True

    def is_dead_end(self, x, y):
        directions_to_check = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        connections = 0
        for direction in directions_to_check:
            temp_x = x + direction[0]
            temp_y = y + direction[1]
            if self.is_walkable((temp_x, temp_y)):
                connections += 1

        return connections <= 1

    def get_opposite_direction(self, new_direction):
        if new_direction == "up":
            return "down"
        if new_direction == "down":
            return "up"
        if new_direction == "left":
            return "right"
        if new_direction == "right":
            return "left"

    def add_side_tunnel(self):
        distances_from_border = []
        for i in range(self.height // 5, self.height * 4 // 5):
            for j in range(1, self.width // 2 - 1):
                if self.is_walkable((j, i)):
                    distances_from_border.append((j, i))
                    break

        # Sort by x coordinate
        distances_from_border.sort(key=lambda tup: tup[0], reverse=True)

        # pick a random position with the highest valid x coordinate
        long_distances = []
        while len(long_distances) < 1:
            long_distances.clear()
            x = distances_from_border[0][0]

            for distance in distances_from_border:
                if distance[0] == x:
                    long_distances.append(distance)
                else:
                    break

            for long_distance in long_distances:
                distances_from_border.remove(long_distance)

            invalid_long_distances = []
            for distance in long_distances:
                for i in range(1, distance[0]-1):
                    # utilities.add_highlighted_tile((i, distance[1]), (255, 255, 0))
                    if self.is_connected((i, distance[1]), 1):
                        invalid_long_distances.append(distance)
                        break

            for invalid_long_distance in invalid_long_distances:
                long_distances.remove(invalid_long_distance)

        y = random.choice(long_distances)[1]

        self.continue_tunel_until_connection(0, y, "right")

    def remove_dead_ends(self):
        while True:
            dead_ends = []
            for i in range(self.height):
                for j in range(self.width // 2):
                    if self.is_walkable((j, i)) and self.is_dead_end(j, i):
                        dead_ends.append((j, i))

            if len(dead_ends) < 1:
                break

            dead_end = random.choice(dead_ends)
            self.maze_data[dead_end[1]][dead_end[0]] = 1
            utilities.add_highlighted_tile(dead_end, (255, 0, 0))

    def is_connected(self, position, number_of_connections):
        directions_to_check = [(-1, 0), (1, 0), (0, -1), (0, 1)]
        connections = 0
        for direction in directions_to_check:
            temp_x = position[0] + direction[0]
            temp_y = position[1] + direction[1]
            if self.is_walkable((temp_x, temp_y)):
                connections += 1

        return connections >= number_of_connections
